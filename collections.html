'Create Free Account'}
              <RocketIcon />
            </button>
          </div>
        </div>
      );
    }

    // ==========================================
    // COLLECTION VIEW COMPONENT
    // ==========================================
    
    function CollectionView({ 
      collection, 
      subCollections, 
      palette, 
      onBack, 
      onEdit, 
      onDelete,
      onDuplicate,
      onShare,
      onCollectionClick,
      onCreateSubCollection,
      onRemoveStyle,
      viewMode,
      onViewModeChange,
      sortOption,
      onSortChange,
      sortCollections
    }) {
      const styles = collection.styles || [];
      const styleCount = styles.length;
      
      // Project starter slots - auto-populate with first 4 styles
      const [projectSlots, setProjectSlots] = useState(() => {
        const initial = [null, null, null, null];
        styles.slice(0, 4).forEach((styleId, i) => {
          initial[i] = styleId;
        });
        return initial;
      });
      
      // Update slots when styles change
      useEffect(() => {
        const newSlots = [null, null, null, null];
        styles.slice(0, 4).forEach((styleId, i) => {
          newSlots[i] = styleId;
        });
        setProjectSlots(newSlots);
      }, [styles.join(',')]);
      
      const getStyleThumbnail = (styleId) => {
        return window.SocietyArts?.getStyleThumbnailUrl?.(styleId, 0) || 
               window.SocietyArts?.getAltStyleThumbnailUrl?.(styleId) ||
               `https://pub-acb560f551f141db830964aed1fa005f.r2.dev/${styleId}/${styleId}-00.webp`;
      };
      
      // Get human-readable style name
      const getStyleName = (styleId) => {
        // Try to get from style data
        const styleData = window.SocietyArts?.styleData?.[styleId] || 
                         window.styleIndex?.find(s => s.id === styleId);
        if (styleData?.name) return styleData.name;
        // Fallback: convert ID to title case
        return styleId.split('-').map(word => 
          word.charAt(0).toUpperCase() + word.slice(1)
        ).join(' ');
      };
      
      const handleStyleClick = (styleId) => {
        if (window.SocietyArts?.openStyleDetailModal) {
          window.SocietyArts.openStyleDetailModal(styleId, {
            collectionId: collection.id,
            collectionName: collection.name,
            onRemove: () => window.location.reload()
          });
        }
      };
      
      const handleAddToProject = (styleId) => {
        // Find first empty slot
        const emptyIndex = projectSlots.findIndex(slot => slot === null);
        if (emptyIndex !== -1) {
          const newSlots = [...projectSlots];
          newSlots[emptyIndex] = styleId;
          setProjectSlots(newSlots);
        }
      };
      
      const handleRemoveFromProject = (index) => {
        const newSlots = [...projectSlots];
        newSlots[index] = null;
        setProjectSlots(newSlots);
      };
      
      const handleStartProject = () => {
        // Get filled slots
        const selectedStyles = projectSlots.filter(s => s !== null);
        if (selectedStyles.length === 0) return;
        
        // Navigate to StoryBuilder with styles
        const stylesParam = selectedStyles.join(',');
        window.location.href = `/story-builder.html?styles=${stylesParam}&collection=${collection.id}`;
      };
      
      const filledSlotCount = projectSlots.filter(s => s !== null).length;
      const isStyleInProject = (styleId) => projectSlots.includes(styleId);
      
      return (
        <>
          {/* Back Navigation */}
          <div className="collections-back-nav">
            <button className="collections-back-btn" onClick={onBack}>
              <ChevronLeftIcon />
              Back
            </button>
          </div>
          
          {/* Project Starter */}
          <div 
            className="project-starter"
            style={{ '--collection-color': collection.color }}
          >
            <div className="project-starter-header">
              <h2 className="project-starter-title">Start a Project</h2>
              <p className="project-starter-subtitle">
                {filledSlotCount === 0 
                  ? 'Select up to 4 styles from your collection' 
                  : `${filledSlotCount} style${filledSlotCount !== 1 ? 's' : ''} selected`}
              </p>
            </div>
            
            <div className="project-starter-slots">
              {projectSlots.map((styleId, index) => (
                <div 
                  key={index}
                  className={`project-slot ${styleId ? 'filled' : ''}`}
                  onClick={() => !styleId && document.querySelector('.style-gallery')?.scrollIntoView({ behavior: 'smooth' })}
                >
                  {styleId ? (
                    <>
                      <img 
                        src={getStyleThumbnail(styleId)} 
                        alt={getStyleName(styleId)}
                        onError={e => e.target.style.opacity = 0.3}
                      />
                      <span className="project-slot-name">{getStyleName(styleId)}</span>
                      <button 
                        className="project-slot-remove"
                        onClick={(e) => {
                          e.stopPropagation();
                          handleRemoveFromProject(index);
                        }}
                        title="Remove from project"
                      >
                        <XIcon />
                      </button>
                    </>
                  ) : (
                    <>
                      <span className="project-slot-number">{index + 1}</span>
                      <span className="project-slot-label">Add style</span>
                    </>
                  )}
                </div>
              ))}
            </div>
            
            <div className="project-starter-action">
              <button 
                className="btn-start-project"
                onClick={handleStartProject}
                disabled={filledSlotCount === 0}
              >
                Start Project
                <ArrowRightIcon />
              </button>
            </div>
          </div>
          
          {/* Collection Info Bar */}
          <div 
            className="collection-info-bar"
            style={{ '--collection-color': collection.color }}
          >
            <div className="collection-info-content">
              <h1 className="collection-info-title">{collection.name}</h1>
              {collection.description && (
                <p className="collection-info-description">{collection.description}</p>
              )}
            </div>
            <div className="collection-info-actions">
              <button className="collection-action-btn" onClick={() => onEdit(collection)}>
                Edit
              </button>
              <button className="collection-action-btn danger" onClick={() => onDelete(collection)}>
                Delete
              </button>
            </div>
          </div>
          
          {/* Styles Gallery */}
          <div className="collection-section-header">
            <h4 className="collection-section-title">Your Styles</h4>
            <span className="collection-section-count">{styleCount} style{styleCount !== 1 ? 's' : ''}</span>
          </div>
          
          <div className="style-gallery">
            {styles.map(styleId => {
              const inProject = isStyleInProject(styleId);
              const canAddToProject = !inProject && projectSlots.some(s => s === null);
              
              return (
                <div 
                  key={styleId} 
                  className={`style-gallery-card ${inProject ? 'in-project' : ''}`}
                  onClick={() => handleStyleClick(styleId)}
                >
                  {inProject && (
                    <span className="style-gallery-badge">In Project</span>
                  )}
                  
                  <div className="style-gallery-actions">
                    {canAddToProject && (
                      <button 
                        className="style-gallery-btn add-to-project"
                        onClick={(e) => {
                          e.stopPropagation();
                          handleAddToProject(styleId);
                        }}
                        title="Add to project"
                      >
                        <PlusIcon />
                      </button>
                    )}
                    <button 
                      className="style-gallery-btn remove"
                      onClick={(e) => {
                        e.stopPropagation();
                        onRemoveStyle(collection.id, styleId);
                      }}
                      title="Remove from collection"
                    >
                      <XIcon />
                    </button>
                  </div>
                  
                  <div className="style-gallery-image">
                    <img 
                      src={getStyleThumbnail(styleId)} 
                      alt={getStyleName(styleId)}
                      onError={e => e.target.style.opacity = 0.3}
                    />
                  </div>
                  
                  <div className="style-gallery-info">
                    <h3 className="style-gallery-name">{getStyleName(styleId)}</h3>
                    <span className="style-gallery-id">{styleId}</span>
                  </div>
                </div>
              );
            })}
            
            {/* Add Styles Card */}
            <div 
              className="style-gallery-add"
              onClick={() => window.location.href = '/style-finder.html'}
            >
              <PlusIcon />
              <span>Add Styles</span>
            </div>
          </div>
        </>
      );
    }

    // ==========================================
    // MAIN COLLECTIONS PAGE COMPONENT
    // ==========================================
    
    function CollectionsPage() {
      const { Header, Sidebar } = window.SocietyArts || {};
      
      if (!Sidebar || !Header) {
        return React.createElement('div', { className: 'loading-state' }, 'Loading...');
      }
      
      const { user, profile, isLoading: authLoading } = window.SocietyArts.useAuth();
      const [collections, setCollections] = useState([]);
      const [palette, setPalette] = useState(DEFAULT_PALETTE);
      const [isLoading, setIsLoading] = useState(true);
      const [authChecked, setAuthChecked] = useState(false);
      const [authModalOpen, setAuthModalOpen] = useState(false);
      const [createModalOpen, setCreateModalOpen] = useState(false);
      const [editingCollection, setEditingCollection] = useState(null);
      const [currentView, setCurrentView] = useState(null); // null = root, or collection object
      const [breadcrumbs, setBreadcrumbs] = useState([]);
      const [createParentId, setCreateParentId] = useState(null);
      const [deleteModalOpen, setDeleteModalOpen] = useState(false);
      const [collectionToDelete, setCollectionToDelete] = useState(null);
      const [shareModalOpen, setShareModalOpen] = useState(false);
      const [collectionToShare, setCollectionToShare] = useState(null);
      
      // Add to Collection Modal state (for ?add= URL parameter)
      const [addStyleModalOpen, setAddStyleModalOpen] = useState(false);
      const [styleToAdd, setStyleToAdd] = useState(null);
      const [styleToAddDetails, setStyleToAddDetails] = useState(null);
      
      // View mode state - load from localStorage or default to 'compact'
      const [viewMode, setViewMode] = useState(() => {
        const saved = localStorage.getItem('collections-view-mode');
        return saved || 'compact';
      });
      
      // Handle view mode change with persistence
      const handleViewModeChange = (mode) => {
        setViewMode(mode);
        localStorage.setItem('collections-view-mode', mode);
      };
      
      // Sort state - load from localStorage or default to 'modified-desc'
      const [sortOption, setSortOption] = useState(() => {
        const saved = localStorage.getItem('collections-sort-option');
        return saved || 'modified-desc';
      });
      
      // Handle sort change with persistence
      const handleSortChange = (option) => {
        setSortOption(option);
        localStorage.setItem('collections-sort-option', option);
      };
      
      // Sort collections based on current sort option
      const sortCollections = (collectionsToSort) => {
        if (!collectionsToSort || collectionsToSort.length === 0) return [];
        
        const sorted = [...collectionsToSort];
        const [field, direction] = sortOption.split('-');
        const isAsc = direction === 'asc';
        
        sorted.sort((a, b) => {
          let comparison = 0;
          
          switch (field) {
            case 'name':
              comparison = (a.name || '').localeCompare(b.name || '');
              break;
            case 'created':
              comparison = new Date(a.created_at || 0) - new Date(b.created_at || 0);
              break;
            case 'modified':
              comparison = new Date(a.updated_at || 0) - new Date(b.updated_at || 0);
              break;
            case 'styles':
              comparison = (a.styles?.length || 0) - (b.styles?.length || 0);
              break;
            default:
              comparison = 0;
          }
          
          return isAsc ? comparison : -comparison;
        });
        
        return sorted;
      };

      // Get Supabase client
      const getSupabase = () => {
        return window.SocietyArts?.supabase || window.supabaseClient || window.supabase;
      };

      // Wait for auth to properly initialize before showing login prompt
      useEffect(() => {
        const checkAuth = async () => {
          // If authLoading is true, wait for it
          if (authLoading) return;
          
          // Double-check session directly from Supabase
          const supabase = getSupabase();
          if (supabase) {
            try {
              const { data: { session } } = await supabase.auth.getSession();
              // If there's a session but no user yet, wait a bit for useAuth to catch up
              if (session && !user) {
                setTimeout(() => setAuthChecked(true), 100);
                return;
              }
            } catch (e) {
              console.log('Session check error:', e);
            }
          }
          
          setAuthChecked(true);
        };
        
        checkAuth();
      }, [authLoading, user]);

      // Handle ?add=STYLE_ID URL parameter
      useEffect(() => {
        const params = new URLSearchParams(window.location.search);
        const addStyleParam = params.get('add');
        
        if (addStyleParam && user && collections.length > 0) {
          setStyleToAdd(addStyleParam);
          
          // Load style details
          const supabase = getSupabase();
          if (supabase) {
            supabase
              .from('styles')
              .select('id, name, thumbnail_url')
              .eq('id', addStyleParam)
              .single()
              .then(({ data }) => {
                setStyleToAddDetails(data);
                setAddStyleModalOpen(true);
              });
          } else {
            setAddStyleModalOpen(true);
          }
          
          // Clear URL parameter
          window.history.replaceState({}, '', window.location.pathname);
        }
      }, [user, collections]);

      // Load palette from admin_settings
      useEffect(() => {
        const loadPalette = async () => {
          try {
            const supabase = getSupabase();
            if (!supabase?.from) {
              console.log('Supabase client not ready, using default palette');
              return;
            }
            const { data, error } = await supabase
              .from('admin_settings')
              .select('value')
              .eq('key', 'collection_palette')
              .single();
            
            if (data?.value?.colors) {
              setPalette(data.value.colors);
            }
          } catch (err) {
            console.log('Using default palette');
          }
        };
        loadPalette();
      }, []);

      // Load collections
      const loadCollections = useCallback(async () => {
        if (!user) return;
        
        setIsLoading(true);
        try {
          const supabase = getSupabase();
          if (!supabase?.from) {
            console.error('Supabase client not available');
            setIsLoading(false);
            return;
          }
          
          const { data, error } = await supabase
            .from('user_collections')
            .select('*')
            .eq('user_id', user.id)
            .order('sort_order', { ascending: true })
            .order('created_at', { ascending: false });
          
          if (error) throw error;
          
          // Calculate subcollection counts
          const withCounts = (data || []).map(col => ({
            ...col,
            subcollection_count: (data || []).filter(c => c.parent_id === col.id).length
          }));
          
          setCollections(withCounts);
        } catch (err) {
          console.error('Error loading collections:', err);
        } finally {
          setIsLoading(false);
        }
      }, [user]);

      useEffect(() => {
        if (user) {
          loadCollections();
        } else if (authChecked && !authLoading) {
          // No user after auth check - stop loading
          setIsLoading(false);
        }
      }, [user, authChecked, authLoading, loadCollections]);

      // Get root collections (no parent)
      const rootCollections = collections.filter(c => !c.parent_id);
      
      // Get sub-collections for current view
      const getSubCollections = (parentId) => {
        return collections.filter(c => c.parent_id === parentId);
      };

      // Handle adding style to existing collection
      const handleAddStyleToCollection = async (collectionId, styleId) => {
        const supabase = getSupabase();
        if (!supabase) throw new Error('No database connection');
        
        const collection = collections.find(c => c.id === collectionId);
        if (!collection) throw new Error('Collection not found');
        
        const updatedStyles = [...(collection.styles || []), styleId];
        
        const { error } = await supabase
          .from('user_collections')
          .update({ 
            styles: updatedStyles,
            updated_at: new Date().toISOString()
          })
          .eq('id', collectionId);
        
        if (error) throw error;
        
        await loadCollections();
      };

      // Handle creating new collection with style
      const handleCreateCollectionWithStyle = async ({ name, color, styleId }) => {
        const supabase = getSupabase();
        if (!supabase || !user) throw new Error('Not authenticated');
        
        const { error } = await supabase
          .from('user_collections')
          .insert({
            user_id: user.id,
            name,
            color,
            styles: [styleId]
          });
        
        if (error) throw error;
        
        await loadCollections();
      };

      // Handle create/update collection
      const handleSaveCollection = async (collectionData) => {
        try {
          const supabase = getSupabase();
          if (!supabase?.from) {
            throw new Error('Supabase client not available');
          }
          
          if (collectionData.id) {
            // Update existing
            const { error } = await supabase
              .from('user_collections')
              .update({
                name: collectionData.name,
                description: collectionData.description,
                color: collectionData.color,
                updated_at: new Date().toISOString()
              })
              .eq('id', collectionData.id)
              .eq('user_id', user.id);
            
            if (error) throw error;
            
            // Update currentView if we're editing the currently viewed collection
            if (currentView?.id === collectionData.id) {
              setCurrentView(prev => ({
                ...prev,
                name: collectionData.name,
                description: collectionData.description,
                color: collectionData.color
              }));
            }
          } else {
            // Create new
            const { error } = await supabase
              .from('user_collections')
              .insert({
                user_id: user.id,
                name: collectionData.name,
                description: collectionData.description,
                color: collectionData.color,
                parent_id: collectionData.parent_id,
                styles: []
              });
            
            if (error) throw error;
          }
          
          await loadCollections();
          setEditingCollection(null);
          setCreateParentId(null);
        } catch (err) {
          console.error('Error saving collection:', err);
          alert('Failed to save collection. Please try again.');
        }
      };

      // Handle delete collection - opens confirmation modal
      const handleDeleteCollection = (collection) => {
        setCollectionToDelete(collection);
        setDeleteModalOpen(true);
      };

      // Confirm delete - actually performs the deletion
      const confirmDeleteCollection = async () => {
        if (!collectionToDelete) return;
        
        try {
          const supabase = getSupabase();
          if (!supabase?.from) {
            throw new Error('Supabase client not available');
          }
          
          const { error } = await supabase
            .from('user_collections')
            .delete()
            .eq('id', collectionToDelete.id);
          
          if (error) throw error;
          
          await loadCollections();
          
          // If we deleted the current view, go back
          if (currentView?.id === collectionToDelete.id) {
            handleBack();
          }
          
          // Close modal and reset state
          setDeleteModalOpen(false);
          setCollectionToDelete(null);
        } catch (err) {
          console.error('Error deleting collection:', err);
          alert('Failed to delete collection. Please try again.');
        }
      };

      // Get sub-collection count for delete modal
      const getSubCollectionCount = (collection) => {
        if (!collection) return 0;
        return collections.filter(c => c.parent_id === collection.id).length;
      };

      // Handle edit collection - opens edit modal
      const handleEditCollection = (collection) => {
        setEditingCollection(collection);
        setCreateModalOpen(true);
      };

      // Handle duplicate collection - deep copy including all contents
      const handleDuplicateCollection = async (collection) => {
        try {
          const supabase = getSupabase();
          
          if (!supabase?.from || !user) {
            throw new Error('Not authenticated');
          }
          
          // Recursive function to duplicate a collection and all its contents
          const duplicateRecursive = async (sourceCollection, newParentId, isRoot = false) => {
            // Create the new collection with styles copied directly
            const { data: newCollection, error: createError } = await supabase
              .from('user_collections')
              .insert({
                user_id: user.id,
                name: isRoot ? `Copy of ${sourceCollection.name}` : sourceCollection.name,
                description: sourceCollection.description,
                color: sourceCollection.color,
                parent_id: newParentId,
                styles: sourceCollection.styles || [] // Copy styles array directly
              })
              .select()
              .single();
            
            if (createError) throw createError;
            
            // Find and duplicate all sub-collections (folders)
            const subCollections = collections.filter(c => c.parent_id === sourceCollection.id);
            
            for (const subCollection of subCollections) {
              // Recursively duplicate each sub-collection with the new parent
              await duplicateRecursive(subCollection, newCollection.id, false);
            }
            
            return newCollection;
          };
          
          // Start the recursive duplication from the selected collection
          await duplicateRecursive(collection, collection.parent_id, true);
          
          await loadCollections();
        } catch (err) {
          console.error('Error duplicating collection:', err);
          alert('Failed to duplicate collection. Please try again.');
        }
      };

      // Handle share collection - opens share modal
      const handleShareCollection = (collection) => {
        setCollectionToShare(collection);
        setShareModalOpen(true);
      };

      // Handle collection click
      const handleCollectionClick = (collection) => {
        setBreadcrumbs(prev => [...prev, currentView].filter(Boolean));
        setCurrentView(collection);
      };

      // Handle back navigation
      const handleBack = () => {
        const prevView = breadcrumbs[breadcrumbs.length - 1] || null;
        setBreadcrumbs(prev => prev.slice(0, -1));
        setCurrentView(prevView);
      };

      // Handle create sub-collection
      const handleCreateSubCollection = () => {
        setCreateParentId(currentView?.id || null);
        setCreateModalOpen(true);
      };

      // Handle remove style from collection
      const handleRemoveStyle = async (collectionId, styleId) => {
        try {
          const supabase = getSupabase();
          if (!supabase?.from) {
            throw new Error('Supabase client not available');
          }
          
          const collection = collections.find(c => c.id === collectionId);
          if (!collection) return;
          
          const updatedStyles = (collection.styles || []).filter(s => s !== styleId);
          
          const { error } = await supabase
            .from('user_collections')
            .update({ 
              styles: updatedStyles,
              updated_at: new Date().toISOString()
            })
            .eq('id', collectionId);
          
          if (error) throw error;
          
          await loadCollections();
          
          // Update current view if we're viewing this collection
          if (currentView?.id === collectionId) {
            setCurrentView(prev => ({ ...prev, styles: updatedStyles }));
          }
        } catch (err) {
          console.error('Error removing style:', err);
        }
      };

      // Build breadcrumb path
      const buildBreadcrumbPath = () => {
        const path = [{ name: 'Collections', onClick: () => { setCurrentView(null); setBreadcrumbs([]); }}];
        
        breadcrumbs.forEach((crumb, index) => {
          if (crumb) {
            path.push({
              name: crumb.name,
              onClick: () => {
                setBreadcrumbs(prev => prev.slice(0, index));
                setCurrentView(crumb);
              }
            });
          }
        });
        
        if (currentView) {
          path.push({ name: currentView.name, onClick: null });
        }
        
        return path;
      };

      const AuthModal = window.SocietyArts?.AuthModal;

      return (
        <div className="page-container">
          <Sidebar />
          <Header user={user} profile={profile} />
          
          <main className="collections-content">
            {/* Breadcrumb */}
            <div className="collections-breadcrumb">
              <a href="index.html">Home</a>
              <ChevronRightIcon />
              {buildBreadcrumbPath().map((crumb, index, arr) => (
                <React.Fragment key={index}>
                  {crumb.onClick ? (
                    <a href="#" onClick={e => { e.preventDefault(); crumb.onClick(); }}>
                      {crumb.name}
                    </a>
                  ) : (
                    <span>{crumb.name}</span>
                  )}
                  {index < arr.length - 1 && <ChevronRightIcon />}
                </React.Fragment>
              ))}
            </div>
            
            {/* Page Header (only when viewing collections list) */}
            {!currentView && user && rootCollections.length > 0 && (
              <div className="collections-header">
                <h1 className="collections-title">Collections</h1>
                <p className="collections-subtitle">Organize and save your favorite art styles</p>
              </div>
            )}
            
            {/* Main Content */}
            {authLoading || isLoading || !authChecked ? (
              <div className="loading-state">Loading...</div>
            ) : !user ? (
              // Not logged in - show explainer with sign up CTA
              <CollectionExplainer 
                isLoggedIn={false}
                onCreateAccount={() => setAuthModalOpen(true)}
                onCreateCollection={() => setCreateModalOpen(true)}
              />
            ) : currentView ? (
              // Collection Detail View
              <CollectionView
                collection={currentView}
                subCollections={getSubCollections(currentView.id)}
                palette={palette}
                onBack={handleBack}
                onEdit={handleEditCollection}
                onDelete={handleDeleteCollection}
                onDuplicate={handleDuplicateCollection}
                onShare={handleShareCollection}
                onCollectionClick={handleCollectionClick}
                onCreateSubCollection={handleCreateSubCollection}
                onRemoveStyle={handleRemoveStyle}
                viewMode={viewMode}
                onViewModeChange={handleViewModeChange}
                sortOption={sortOption}
                onSortChange={handleSortChange}
                sortCollections={sortCollections}
              />
            ) : rootCollections.length === 0 ? (
              // Empty State - logged in but no collections
              <CollectionExplainer 
                isLoggedIn={true}
                onCreateAccount={() => setAuthModalOpen(true)}
                onCreateCollection={() => setCreateModalOpen(true)}
              />
            ) : (
              // Root Collections Grid
              <>
                <CollectionsToolbar 
                  onAddCollection={() => setCreateModalOpen(true)}
                  viewMode={viewMode}
                  onViewChange={handleViewModeChange}
                  sortOption={sortOption}
                  onSortChange={handleSortChange}
                />
                {viewMode === 'table' ? (
                  <CollectionsTable
                    collections={sortCollections(rootCollections)}
                    palette={palette}
                    onClick={handleCollectionClick}
                    onEdit={handleEditCollection}
                    onDelete={handleDeleteCollection}
                    onDuplicate={handleDuplicateCollection}
                    onShare={handleShareCollection}
                    sortOption={sortOption}
                    onSortChange={handleSortChange}
                  />
                ) : (
                  <div className={`collections-grid view-${viewMode}`}>
                    {sortCollections(rootCollections).map(collection => (
                      <CollectionCard 
                        key={collection.id}
                        collection={collection}
                        palette={palette}
                        onClick={handleCollectionClick}
                        onEdit={handleEditCollection}
                        onDelete={handleDeleteCollection}
                        onDuplicate={handleDuplicateCollection}
                        onShare={handleShareCollection}
                        viewMode={viewMode}
                      />
                    ))}
                  </div>
                )}
              </>
            )}
          </main>
          
          {/* Auth Modal */}
          {authModalOpen && AuthModal && (
            <AuthModal 
              isOpen={authModalOpen}
              onClose={() => setAuthModalOpen(false)}
            />
          )}
          
          {/* Create/Edit Modal */}
          <CollectionModal
            isOpen={createModalOpen || !!editingCollection}
            onClose={() => {
              setCreateModalOpen(false);
              setEditingCollection(null);
              setCreateParentId(null);
            }}
            onSave={handleSaveCollection}
            collection={editingCollection}
            palette={palette}
            parentId={createParentId}
          />
          
          {/* Delete Confirmation Modal */}
          <DeleteConfirmationModal
            isOpen={deleteModalOpen}
            onClose={() => {
              setDeleteModalOpen(false);
              setCollectionToDelete(null);
            }}
            onConfirm={confirmDeleteCollection}
            collection={collectionToDelete}
            subCollectionCount={getSubCollectionCount(collectionToDelete)}
          />
          
          {/* Share Modal */}
          <ShareModal
            isOpen={shareModalOpen}
            onClose={() => {
              setShareModalOpen(false);
              setCollectionToShare(null);
            }}
            collection={collectionToShare}
          />
          
          {/* Add Style to Collection Modal (from ?add= URL parameter) */}
          <AddStyleToCollectionModal
            isOpen={addStyleModalOpen}
            onClose={() => {
              setAddStyleModalOpen(false);
              setStyleToAdd(null);
              setStyleToAddDetails(null);
            }}
            styleId={styleToAdd}
            styleDetails={styleToAddDetails}
            collections={rootCollections}
            palette={palette}
            onAddToCollection={handleAddStyleToCollection}
            onCreateCollection={handleCreateCollectionWithStyle}
          />
        </div>
      );
    }

    // ==========================================
    // INITIALIZE APP
    // ==========================================
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    
    function waitForComponents(callback, maxAttempts = 50) {
      let attempts = 0;
      const check = () => {
        attempts++;
        const hasComponents = window.SocietyArts?.Sidebar && window.SocietyArts?.Header && window.SocietyArts?.useAuth;
        const hasSupabase = window.SocietyArts?.supabase?.from || window.supabaseClient?.from || window.supabase?.from;
        
        if (hasComponents && hasSupabase) {
          callback();
        } else if (attempts < maxAttempts) {
          setTimeout(check, 100);
        } else {
          console.error('Components or Supabase failed to load');
          callback();
        }
      };
      check();
    }
    
    waitForComponents(() => {
      root.render(<CollectionsPage />);
    });
  </script>
</body>
</html>
